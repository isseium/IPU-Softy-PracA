\documentclass[a4j]{jarticle}

\begin{document}

\section{標準出力と標準エラー出力}

標準出力と標準エラー出力が別になることで、プログラムの処理結果であるかユーザに対するエラーメッセージであるのかが区別される。仮に標準エラー出力が無かった場合、標準出力をファイルに変更したり、他プロセスと結合した場合に、ユーザがエラーの発生に気づくことができない。その結果、次の処理へエラーのデータを転送してしまい意図しない処理をしてしまう可能性がある。

\section{カレントディレクトリとディレクトリスタック}
コマンドを順に入力すると、コマンドを実行するごとに以下のようにカレントディレクトリおよびディレクトリスタックが変化する。\\
\begin{center} 
\begin{tabular}{|l|l|}
  \hline
  実行コマンド & カレントディレクトリとディレクトリスタックの変化\\
  \hline
  cd /usr & カレントディレクトリを/usrにする。スタックディレクトリには変化がない。\\
  pushd /home & カレントディレクトリを/homeにする。/usrがスタックの一番上に追加される。\\
  pushd & スタックの一番上(/usr)とカレントディレクトリ(/home)を入れ替える。\\
  cd local4/doc & カレントディレクトリを/usr/local4/docにする。スタックディレクトリには変化がない。\\
  popd & スタックディレクトリの一番上のディレクトリ(/home)をカレントディレクトリとする。\\
  \hline
 \end{tabular}
\end{center}

\section{リダイレクションとパイプを使った処理}
\subparagraph{方法１\\}
catコマンドでlsout.txtを読み込み、出力結果をパイプを通してcatコマンドに渡し、さらにその出力結果をリダイレクションを用いてlsout.txtに出力する。

すなわち以下のコマンドを実行する。

cat lsout.txt \textbar  cat -n \textgreater lsout.txt\\

\subparagraph{方法２\\} 
catコマンドでlsout.txtを読み込み、リダイレクションを用いて一時ファイルへ出力し、mvコマンドを用いて一時ファイルのファイル名をlsout.txtに変更する。

すなわち以下のコマンドを実行する。（一時ファイル名をtmp.txtとする。）

cat -n lsout.txt \textgreater tmp.txt

mv tmp.txt lsout.txt\\

\subparagraph{補足\\}
はじめ私は、１行だけのコマンドで指示された処理を行おうと試み、方法１の方法を考え実際に処理を正常に行うことができたが、先輩からの指摘により方法１では欠陥があるということがわかった。

欠陥の原因は、OSはファイルを読み込みながら同じファイルに書き込みをするという処理はできないため、リダイレクションを行う際に同じファイルを入出力に指定してはいけないということであった。しかし、なぜ方法１の処理が正常に行えたかというと今回のlsout.txt程度のファイル容量であれば、読み込む際にファイルをすべてキャッシュで保持することができるため、操作側では読み書きを同時に行っているような処理を行えるということであった。そのため、キャッシュのサイズを上回るようなファイルを対象にして実行するとエラーが発生する。

結論として、方法１は１行だけのコマンドで処理を行うことができ、一時ファイルも必要ないが、上のような制限があるだけでなく、方法２のほうが処理の内容が簡潔でわかりやすいため実際には方法２を実行すべきであると思う。\\

\section{echoを使った処理}
echoの出力先を\textgreater \textgreater を用いて行ごとに内容をファイルへ追加することで、２行以上の長い内容を持つファイルを作成することができる。\\

\section{setコマンドを用いた処理}
指示されたコマンドを順に実行すると、最後のコマンドを実行した際にファイルに上書きをすることができないという旨のエラーメッセージが表示される。

インターネットを用いて set -C について調べてみると、set -C（set noclobber）はリダイレクションによる既存ファイルへの上書きを禁止し、set +C（unset noclobber）はそれを解除するコマンドであるということがわかった。\\
\paragraph{参考サイト\\}
サイト名：Windowsユーザーのlinux入門  setコマンド\\
\hspace*{1zw}URL：http://www.glasscom.com/tone/linux/Reference/Bash/BashSet.htm\\

\section{ファイルのサイズと圧縮}
指示されたコマンドを実行して manls.txt を作成し、ls -l manls.txt と実行することでファイルサイズを取得することができ、ファイルサイズは16601byteであった。

次に manls.txt を manls\_orig.txt にコピーし、 compress manls.txt と実行して圧縮ファイルを作成し、ファイルサイズを上と同様に取得すると、7880byteであった。

そして、uncompress manls.txt.Z と実行し復元してファイルサイズを取得すると、16601byteであった。

ファイルとファイルサイズをまとめると以下の通りである。\\

\begin{center}
\begin{tabular}{|l|r|}
\hline
ファイル名 & ファイルサイズ(byte)\\
\hline
manls\_orig.txt & 16601\\
manls.txt.Z & 7880\\
manls.txt & 16601\\
\hline
\end{tabular}
\end{center}

このことから、圧縮することでファイルサイズを小さくすることができることがわかった。また今回の場合はファイルサイズを半分以下にすることができた。\\

\section{ファイルの移動}
まず、mkdirコマンド用いて、mkdir SoftA と実行することでSoftAディレクトリを作成
し、これまでソフトウェア演習Aで作成したファイルをそれぞれmvコマンドを用いて移動させる。

例えば、ホームディレクトリにある、report.txtを移動させたい場合は、 mv report.txt SoftA と実行する。


\section{ディレクトリ内のファイルの移動}
\begin{itemize}
\item ひとつずつファイルを移動する。\\
はじめに一時ディレクトリを作成する。次にmvコマンドを用いて、一方のディレクトリのファイルをひとつずつ一時ディレクトリへ移動する。そして、もう一方のディレクトリにあるファイルを空になったディレクトリへ移動し、さらに一時ディレクトリからファイルを目的のディレクトリへ移動する。\\
\item ディレクトリ名を変更する。\\
mvコマンドを用いて、ディレクトリ名をそれぞれ変更する。\\
注意点としては、片方のディレクトリ名を一時的な名前に変更を行ってから実行する必要がある。\\
\end{itemize}

\section{指定行の削除}
\paragraph{head,tailコマンドを用いた方法\\}
100行あるファイルをA、50行目を削除したファイルBとする。\\
Aのファイルの先頭から49行目までを取りだし、リダイレクションを用いてBへ出力する。\\
つぎに、Aのファイルの最後尾から49行目までを取りだし、リダイレクション（＞＞）を用いてBへ追加する。これで、50行目を削除したファイルBを作成することができる。\\
コマンド手順は以下の通りである。\\
 head -49 A \textgreater B\\
 tail -49 A \textgreater\textgreater B\\


\section{\textless \textless の意味}
\begin{itemize}
\item 調査方法\\
研究室にある「入門bash」のp.179ページを調べた。\\
\item 調べた結果\\
\textless \textless は、コマンドへの入力が標準入力になるようにするものであり、指定した文字列が表示されるまで１行ずつ入力することができる。しかし、コマンドプロンプトで使用してもあまり意味がなく、シェルスクリプトで使用されることを前提としている。\\
\end{itemize}

\section{csh,tcsh等でのリダイレクション}
\begin{itemize}
\item 標準出力のリダイレクション\\
bashと同様に、\textgreater を用いる。\\
\item 標準エラー出力のリダイレクション\\
\textgreater \& を用いる。\\
\end{itemize}

\end{document}



